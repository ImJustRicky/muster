#!/usr/bin/env bash
# muster-mcp — MCP stdio transport for muster
# Reads JSON-RPC from stdin, executes muster operations, returns JSON to stdout.
# Requires: jq
set -uo pipefail

MUSTER_VERSION="0.1.0"

# Resolve symlinks (macOS bash 3.2 has no readlink -f)
_muster_self="${BASH_SOURCE[0]}"
while [[ -L "$_muster_self" ]]; do
  _muster_dir="$(cd "$(dirname "$_muster_self")" && pwd)"
  _muster_self="$(readlink "$_muster_self")"
  [[ "$_muster_self" != /* ]] && _muster_self="${_muster_dir}/${_muster_self}"
done
MUSTER_ROOT="$(cd "$(dirname "$_muster_self")/.." && pwd)"
unset _muster_self _muster_dir

# ── Core libs (for config reading) ──
source "$MUSTER_ROOT/lib/core/utils.sh"
source "$MUSTER_ROOT/lib/core/config.sh"
source "$MUSTER_ROOT/lib/core/platform.sh"
source "$MUSTER_ROOT/lib/core/scanner.sh"
source "$MUSTER_ROOT/lib/core/remote.sh"

# ── Override EXIT trap — utils.sh writes ANSI to stdout which corrupts protocol ──
trap 'true' EXIT

# ── Require jq ──
if ! command -v jq &>/dev/null; then
  printf '{"jsonrpc":"2.0","error":{"code":-32603,"message":"jq is required for muster-mcp"},"id":null}\n'
  exit 1
fi

# ── Logging (stderr only — stdout is protocol) ──
_log() { echo "[muster-mcp] $*" >&2; }

# ── JSON helpers ──
json_str() {
  printf '%s' "$1" | jq -Rs .
}

json_response() {
  local id="$1" result="$2"
  printf '{"jsonrpc":"2.0","id":%s,"result":%s}\n' "$id" "$result"
}

json_error() {
  local id="$1" code="$2" msg="$3"
  printf '{"jsonrpc":"2.0","id":%s,"error":{"code":%s,"message":%s}}\n' "$id" "$code" "$(json_str "$msg")"
}

json_tool_result() {
  local id="$1" text="$2"
  local escaped
  escaped=$(json_str "$text")
  printf '{"jsonrpc":"2.0","id":%s,"result":{"content":[{"type":"text","text":%s}]}}\n' "$id" "$escaped"
}

# ── In-memory credential storage (session-scoped, never written to disk) ──
# Parallel arrays since bash 3.2 has no associative arrays
_CRED_KEYS=()   # "service:KEY_NAME"
_CRED_VALS=()   # "the_value"

# ── Strip ANSI escape codes ──
strip_ansi() {
  sed 's/\x1b\[[0-9;]*[a-zA-Z]//g; s/\x1b\[[0-9;]*m//g; s/\x1b(B//g'
}

# ── Tool definitions ──
TOOLS_JSON='[
  {
    "name": "muster_list_services",
    "description": "List all configured services and their health check types",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        }
      },
      "required": ["project_dir"]
    }
  },
  {
    "name": "muster_status",
    "description": "Check health status of all services. Returns each service as healthy, unhealthy, or no health check.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        }
      },
      "required": ["project_dir"]
    }
  },
  {
    "name": "muster_deploy",
    "description": "Deploy services. Runs deploy hooks in configured order and verifies health after each.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        },
        "service": {
          "type": "string",
          "description": "Service key to deploy. Omit to deploy all services."
        }
      },
      "required": ["project_dir"]
    }
  },
  {
    "name": "muster_rollback",
    "description": "Rollback a service to its previous state using the rollback hook.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        },
        "service": {
          "type": "string",
          "description": "Service key to rollback"
        }
      },
      "required": ["project_dir", "service"]
    }
  },
  {
    "name": "muster_logs",
    "description": "Get recent deploy logs for a service.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        },
        "service": {
          "type": "string",
          "description": "Service key to get logs for"
        },
        "lines": {
          "type": "number",
          "description": "Number of log lines to return (default: 50)"
        }
      },
      "required": ["project_dir", "service"]
    }
  },
  {
    "name": "muster_cleanup",
    "description": "Clean up old deploy logs and run cleanup hooks for all services.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        }
      },
      "required": ["project_dir"]
    }
  },
  {
    "name": "muster_config",
    "description": "Get the full deploy.json configuration for the project.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        }
      },
      "required": ["project_dir"]
    }
  },
  {
    "name": "muster_scan_project",
    "description": "Scan a project directory and detect what services might be needed based on files found (Dockerfile, docker-compose.yml, package.json, go.mod, Cargo.toml, requirements.txt, etc). Use this to help users figure out what services to configure.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory to scan"
        }
      },
      "required": ["project_dir"]
    }
  },
  {
    "name": "muster_init_project",
    "description": "Create or update deploy.json for a project. Provide the full JSON config as a string. Also creates .muster/hooks/<service>/ directories and .muster/logs/. Updates .gitignore to exclude .muster/logs/.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory"
        },
        "config": {
          "type": "string",
          "description": "The full deploy.json content as a JSON string"
        }
      },
      "required": ["project_dir", "config"]
    }
  },
  {
    "name": "muster_write_hook",
    "description": "Write a hook script for a service. Creates the hook directory if needed and makes the script executable. Hook types: deploy.sh, health.sh, rollback.sh, logs.sh, cleanup.sh.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        },
        "service": {
          "type": "string",
          "description": "Service key (e.g. api, redis, postgres)"
        },
        "hook": {
          "type": "string",
          "description": "Hook filename: deploy.sh, health.sh, rollback.sh, logs.sh, or cleanup.sh"
        },
        "content": {
          "type": "string",
          "description": "The bash script content for the hook"
        }
      },
      "required": ["project_dir", "service", "hook", "content"]
    }
  },
  {
    "name": "muster_read_hook",
    "description": "Read the contents of a hook script for a service. Returns the script content or indicates the hook does not exist.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory containing deploy.json"
        },
        "service": {
          "type": "string",
          "description": "Service key (e.g. api, redis, postgres)"
        },
        "hook": {
          "type": "string",
          "description": "Hook filename: deploy.sh, health.sh, rollback.sh, logs.sh, or cleanup.sh"
        }
      },
      "required": ["project_dir", "service", "hook"]
    }
  },
  {
    "name": "muster_set_credential",
    "description": "Store a credential for a service in memory for this session. Credentials are passed to hook scripts as MUSTER_CRED_<KEY> environment variables during deploy and rollback. Never written to disk or logged. Use for passwords, API keys, tokens, etc.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory"
        },
        "service": {
          "type": "string",
          "description": "Service key (e.g. api, redis, postgres)"
        },
        "key": {
          "type": "string",
          "description": "Credential key name (e.g. SSH_PASSWORD, DB_PASSWORD, API_KEY). Will be available as MUSTER_CRED_<KEY> in hooks."
        },
        "value": {
          "type": "string",
          "description": "The credential value (password, token, etc.)"
        }
      },
      "required": ["project_dir", "service", "key", "value"]
    }
  },
  {
    "name": "muster_list_credentials",
    "description": "List what credential keys are stored for each service. Shows key names only, never values.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory"
        }
      },
      "required": ["project_dir"]
    }
  },
  {
    "name": "muster_clear_credentials",
    "description": "Wipe all stored credentials from memory.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "project_dir": {
          "type": "string",
          "description": "Path to the project directory"
        }
      },
      "required": ["project_dir"]
    }
  }
]'

# ── Load config for a project dir ──
load_project_config() {
  local dir="$1"
  if [[ ! -f "${dir}/deploy.json" ]]; then
    return 1
  fi
  CONFIG_FILE="${dir}/deploy.json"
  return 0
}

# ── Tool implementations ──

tool_list_services() {
  local dir="$1"
  load_project_config "$dir" || { echo "No deploy.json found in ${dir}"; return 1; }

  local output=""
  local services
  services=$(config_services)

  while IFS= read -r svc; do
    [[ -z "$svc" ]] && continue
    local name health_type
    name=$(config_get ".services.${svc}.name")
    health_type=$(config_get ".services.${svc}.health.type")
    local has_deploy="false" has_rollback="false" has_logs="false"
    [[ -x "${dir}/.muster/hooks/${svc}/deploy.sh" ]] && has_deploy="true"
    [[ -x "${dir}/.muster/hooks/${svc}/rollback.sh" ]] && has_rollback="true"
    [[ -x "${dir}/.muster/hooks/${svc}/logs.sh" ]] && has_logs="true"
    local remote_info=""
    if remote_is_enabled "$svc"; then
      local r_host r_user
      r_host=$(config_get ".services.${svc}.remote.host")
      r_user=$(config_get ".services.${svc}.remote.user")
      remote_info=", remote: ${r_user}@${r_host}"
    fi
    output="${output}${svc}: ${name} (health: ${health_type}, deploy: ${has_deploy}, rollback: ${has_rollback}, logs: ${has_logs}${remote_info})\n"
  done <<< "$services"

  printf '%b' "$output"
}

tool_status() {
  local dir="$1"
  load_project_config "$dir" || { echo "No deploy.json found in ${dir}"; return 1; }

  local output=""
  local services
  services=$(config_services)

  while IFS= read -r svc; do
    [[ -z "$svc" ]] && continue
    local name
    name=$(config_get ".services.${svc}.name")
    local hook="${dir}/.muster/hooks/${svc}/health.sh"

    if [[ -x "$hook" ]]; then
      if "$hook" &>/dev/null; then
        output="${output}${svc} (${name}): HEALTHY\n"
      else
        output="${output}${svc} (${name}): UNHEALTHY\n"
      fi
    else
      output="${output}${svc} (${name}): NO HEALTH CHECK\n"
    fi
  done <<< "$services"

  printf '%b' "$output"
}

tool_deploy() {
  local dir="$1" target="${2:-all}"
  load_project_config "$dir" || { echo "No deploy.json found in ${dir}"; return 1; }

  local log_dir="${dir}/.muster/logs"
  mkdir -p "$log_dir"

  local services=()
  if [[ "$target" == "all" ]]; then
    while IFS= read -r svc; do
      [[ -z "$svc" ]] && continue
      local skip
      skip=$(config_get ".services.${svc}.skip_deploy")
      [[ "$skip" == "true" ]] && continue
      services[${#services[@]}]="$svc"
    done < <(config_get '.deploy_order[]' 2>/dev/null || config_services)
  else
    services[0]="$target"
  fi

  local output=""
  for svc in "${services[@]}"; do
    local name
    name=$(config_get ".services.${svc}.name")
    local hook="${dir}/.muster/hooks/${svc}/deploy.sh"

    if [[ ! -x "$hook" ]]; then
      output="${output}${svc} (${name}): SKIPPED (no deploy hook)\n"
      continue
    fi

    local log_file="${log_dir}/${svc}-deploy-$(date +%Y%m%d-%H%M%S).log"
    _export_creds_for_service "$svc"
    if "$hook" >> "$log_file" 2>&1; then
      output="${output}${svc} (${name}): DEPLOYED"
      # Health check
      local health_hook="${dir}/.muster/hooks/${svc}/health.sh"
      if [[ -x "$health_hook" ]]; then
        if "$health_hook" &>/dev/null; then
          output="${output} — HEALTHY\n"
        else
          output="${output} — HEALTH CHECK FAILED\n"
        fi
      else
        output="${output}\n"
      fi
    else
      output="${output}${svc} (${name}): DEPLOY FAILED (exit code $?)\n"
    fi
    _unexport_creds_for_service "$svc"
  done

  printf '%b' "$output"
}

tool_rollback() {
  local dir="$1" target="$2"
  load_project_config "$dir" || { echo "No deploy.json found in ${dir}"; return 1; }

  local hook="${dir}/.muster/hooks/${target}/rollback.sh"
  if [[ ! -x "$hook" ]]; then
    echo "No rollback hook for ${target}"
    return 1
  fi

  local name
  name=$(config_get ".services.${target}.name")
  local log_dir="${dir}/.muster/logs"
  mkdir -p "$log_dir"
  local log_file="${log_dir}/${target}-rollback-$(date +%Y%m%d-%H%M%S).log"

  _export_creds_for_service "$target"
  if "$hook" >> "$log_file" 2>&1; then
    echo "${target} (${name}): ROLLED BACK"
  else
    echo "${target} (${name}): ROLLBACK FAILED (exit code $?)"
  fi
  _unexport_creds_for_service "$target"
}

tool_logs() {
  local dir="$1" target="$2" lines="${3:-50}"
  load_project_config "$dir" || { echo "No deploy.json found in ${dir}"; return 1; }

  local log_dir="${dir}/.muster/logs"
  local latest
  latest=$(ls -t "${log_dir}/${target}-"*.log 2>/dev/null | head -1)

  if [[ -n "$latest" ]]; then
    echo "=== $(basename "$latest") ==="
    tail -n "$lines" "$latest" | strip_ansi
  else
    echo "No logs found for ${target}"
  fi
}

tool_cleanup() {
  local dir="$1"
  load_project_config "$dir" || { echo "No deploy.json found in ${dir}"; return 1; }

  local output=""
  local services
  services=$(config_services)

  while IFS= read -r svc; do
    [[ -z "$svc" ]] && continue
    local hook="${dir}/.muster/hooks/${svc}/cleanup.sh"
    if [[ -x "$hook" ]]; then
      local name
      name=$(config_get ".services.${svc}.name")
      "$hook" &>/dev/null
      output="${output}${name}: cleaned up\n"
    fi
  done <<< "$services"

  local log_dir="${dir}/.muster/logs"
  if [[ -d "$log_dir" ]]; then
    local old_logs
    old_logs=$(find "$log_dir" -name "*.log" -mtime +7 2>/dev/null | wc -l | tr -d ' ')
    if (( old_logs > 0 )); then
      find "$log_dir" -name "*.log" -mtime +7 -delete 2>/dev/null
      output="${output}Removed ${old_logs} old log files\n"
    fi
  fi

  [[ -z "$output" ]] && output="Nothing to clean up\n"
  printf '%b' "$output"
}

tool_config() {
  local dir="$1"
  load_project_config "$dir" || { echo "No deploy.json found in ${dir}"; return 1; }
  cat "$CONFIG_FILE"
}

tool_scan_project() {
  local dir="$1"
  if [[ ! -d "$dir" ]]; then
    echo "Directory not found: ${dir}"
    return 1
  fi

  # Use shared scanner
  scan_project "$dir"

  # Build files JSON array
  local files_json="["
  local i=0
  while (( i < ${#_SCAN_FILES[@]} )); do
    local entry="${_SCAN_FILES[$i]}"
    local file="${entry%%|*}"
    local desc="${entry#*|}"
    if (( i > 0 )); then
      files_json="${files_json},"
    fi
    files_json="${files_json}{\"file\":$(json_str "$file"),\"description\":$(json_str "$desc")}"
    i=$((i + 1))
  done
  files_json="${files_json}]"

  # Build services JSON array
  local services_json="["
  i=0
  while (( i < ${#_SCAN_SERVICES[@]} )); do
    if (( i > 0 )); then
      services_json="${services_json},"
    fi
    services_json="${services_json}$(json_str "${_SCAN_SERVICES[$i]}")"
    i=$((i + 1))
  done
  services_json="${services_json}]"

  # Build paths JSON object: { "service": { "type": "path", ... }, ... }
  local paths_json="{"
  local first_path=true
  i=0
  while (( i < ${#_SCAN_PATHS[@]} )); do
    local entry="${_SCAN_PATHS[$i]}"
    local p_svc="${entry%%|*}"
    local rest="${entry#*|}"
    local p_type="${rest%%|*}"
    local p_path="${rest#*|}"
    if [[ "$first_path" == "true" ]]; then
      first_path=false
    else
      paths_json="${paths_json},"
    fi
    paths_json="${paths_json}$(json_str "$p_svc"):{$(json_str "$p_type"):$(json_str "$p_path")}"
    i=$((i + 1))
  done
  paths_json="${paths_json}}"

  # Stack string
  local stack_json
  if [[ -n "$_SCAN_STACK" ]]; then
    stack_json=$(json_str "$_SCAN_STACK")
  else
    stack_json="null"
  fi

  # Compose final JSON via jq for correctness (merges duplicate service keys in paths)
  printf '%s\n' "{\"files\":${files_json},\"services\":${services_json},\"stack\":${stack_json},\"paths\":${paths_json}}" | jq -c '
    # Merge paths: group entries by service key, combine type objects
    .paths as $p |
    .paths = (reduce ($p | to_entries[]) as $e ({}; .[$e.key] = ((.[$e.key] // {}) + $e.value))) |
    .
  '
}

tool_init_project() {
  local dir="$1" config="$2"

  if [[ ! -d "$dir" ]]; then
    echo "Directory not found: ${dir}"
    return 1
  fi

  # Validate JSON
  if ! printf '%s\n' "$config" | jq . &>/dev/null; then
    echo "Invalid JSON config"
    return 1
  fi

  # Write deploy.json
  printf '%s\n' "$config" | jq . > "${dir}/deploy.json"

  # Create .muster structure
  mkdir -p "${dir}/.muster/logs"

  # Create hook directories for each service
  local services
  services=$(printf '%s\n' "$config" | jq -r '.services | keys[]' 2>/dev/null)
  while IFS= read -r svc; do
    [[ -z "$svc" ]] && continue
    mkdir -p "${dir}/.muster/hooks/${svc}"
  done <<< "$services"

  # Update .gitignore
  local gitignore="${dir}/.gitignore"
  if [[ -f "$gitignore" ]]; then
    if ! grep -q '.muster/logs' "$gitignore" 2>/dev/null; then
      printf '\n# muster deploy logs\n.muster/logs/\n' >> "$gitignore"
    fi
  else
    printf '# muster deploy logs\n.muster/logs/\n' > "$gitignore"
  fi

  local output="Created deploy.json\nCreated .muster/logs/\n"
  while IFS= read -r svc; do
    [[ -z "$svc" ]] && continue
    output="${output}Created .muster/hooks/${svc}/\n"
  done <<< "$services"
  output="${output}Updated .gitignore\n\nProject initialized. Write hook scripts with muster_write_hook."

  printf '%b' "$output"
}

tool_write_hook() {
  local dir="$1" service="$2" hook="$3" content="$4"

  # Validate hook name
  case "$hook" in
    deploy.sh|health.sh|rollback.sh|logs.sh|cleanup.sh) ;;
    *) echo "Invalid hook: ${hook}. Must be deploy.sh, health.sh, rollback.sh, logs.sh, or cleanup.sh"; return 1 ;;
  esac

  local hook_dir="${dir}/.muster/hooks/${service}"
  mkdir -p "$hook_dir"

  local hook_file="${hook_dir}/${hook}"
  printf '%s\n' "$content" > "$hook_file"
  chmod +x "$hook_file"

  echo "Wrote ${hook} for ${service} ($(wc -l < "$hook_file" | tr -d ' ') lines, executable)"
}

tool_read_hook() {
  local dir="$1" service="$2" hook="$3"

  local hook_file="${dir}/.muster/hooks/${service}/${hook}"
  if [[ -f "$hook_file" ]]; then
    echo "=== ${service}/${hook} ==="
    cat "$hook_file"
  else
    echo "Hook not found: ${service}/${hook}"
    # Show what hooks exist for this service
    local hook_dir="${dir}/.muster/hooks/${service}"
    if [[ -d "$hook_dir" ]]; then
      local existing
      existing=$(ls "$hook_dir" 2>/dev/null)
      if [[ -n "$existing" ]]; then
        echo "Existing hooks for ${service}: ${existing}"
      else
        echo "No hooks exist for ${service}"
      fi
    else
      echo "No hook directory for ${service}"
    fi
  fi
}

# ── Credential tools ──

tool_set_credential() {
  local service="$1" key="$2" value="$3"

  # Update existing or add new
  local entry="${service}:${key}"
  local i=0
  while (( i < ${#_CRED_KEYS[@]} )); do
    if [[ "${_CRED_KEYS[$i]}" == "$entry" ]]; then
      _CRED_VALS[$i]="$value"
      echo "Updated credential ${key} for ${service}"
      return
    fi
    (( i++ ))
  done

  _CRED_KEYS[${#_CRED_KEYS[@]}]="$entry"
  _CRED_VALS[${#_CRED_VALS[@]}]="$value"
  echo "Stored credential ${key} for ${service}"
}

tool_list_credentials() {
  if (( ${#_CRED_KEYS[@]} == 0 )); then
    echo "No credentials stored"
    return
  fi

  local output=""
  local last_svc=""
  local keys_for_svc=""
  local i=0
  # Collect keys grouped by service
  while (( i < ${#_CRED_KEYS[@]} )); do
    local entry="${_CRED_KEYS[$i]}"
    local svc="${entry%%:*}"
    local key="${entry#*:}"
    if [[ "$svc" != "$last_svc" ]]; then
      if [[ -n "$last_svc" ]]; then
        output="${output}${last_svc}: ${keys_for_svc}\n"
      fi
      last_svc="$svc"
      keys_for_svc="$key"
    else
      keys_for_svc="${keys_for_svc}, ${key}"
    fi
    (( i++ ))
  done
  if [[ -n "$last_svc" ]]; then
    output="${output}${last_svc}: ${keys_for_svc}\n"
  fi

  printf '%b' "$output"
}

tool_clear_credentials() {
  local count=${#_CRED_KEYS[@]}
  _CRED_KEYS=()
  _CRED_VALS=()
  echo "Cleared ${count} credential(s)"
}

# Export credentials as env vars for a service before running hooks
_export_creds_for_service() {
  local service="$1"
  local i=0
  while (( i < ${#_CRED_KEYS[@]} )); do
    local entry="${_CRED_KEYS[$i]}"
    local svc="${entry%%:*}"
    local key="${entry#*:}"
    if [[ "$svc" == "$service" ]]; then
      export "MUSTER_CRED_${key}=${_CRED_VALS[$i]}"
    fi
    (( i++ ))
  done
}

# Unexport credentials after hook runs
_unexport_creds_for_service() {
  local service="$1"
  local i=0
  while (( i < ${#_CRED_KEYS[@]} )); do
    local entry="${_CRED_KEYS[$i]}"
    local svc="${entry%%:*}"
    local key="${entry#*:}"
    if [[ "$svc" == "$service" ]]; then
      unset "MUSTER_CRED_${key}"
    fi
    (( i++ ))
  done
}

# ── Handle tools/call ──
handle_call() {
  local msg="$1" id="$2"
  local tool_name project_dir
  tool_name=$(printf '%s\n' "$msg" | jq -r '.params.name')
  project_dir=$(printf '%s\n' "$msg" | jq -r '.params.arguments.project_dir // empty')

  if [[ -z "$project_dir" ]]; then
    json_error "$id" -32602 "project_dir is required"
    return
  fi

  local result=""
  case "$tool_name" in
    muster_list_services)
      result=$(tool_list_services "$project_dir" 2>&1) ;;
    muster_status)
      result=$(tool_status "$project_dir" 2>&1) ;;
    muster_deploy)
      local service
      service=$(printf '%s\n' "$msg" | jq -r '.params.arguments.service // empty')
      result=$(tool_deploy "$project_dir" "${service:-all}" 2>&1) ;;
    muster_rollback)
      local service
      service=$(printf '%s\n' "$msg" | jq -r '.params.arguments.service // empty')
      if [[ -z "$service" ]]; then
        json_error "$id" -32602 "service is required for rollback"
        return
      fi
      result=$(tool_rollback "$project_dir" "$service" 2>&1) ;;
    muster_logs)
      local service lines
      service=$(printf '%s\n' "$msg" | jq -r '.params.arguments.service // empty')
      lines=$(printf '%s\n' "$msg" | jq -r '.params.arguments.lines // 50')
      if [[ -z "$service" ]]; then
        json_error "$id" -32602 "service is required for logs"
        return
      fi
      result=$(tool_logs "$project_dir" "$service" "$lines" 2>&1) ;;
    muster_cleanup)
      result=$(tool_cleanup "$project_dir" 2>&1) ;;
    muster_config)
      result=$(tool_config "$project_dir" 2>&1) ;;
    muster_scan_project)
      result=$(tool_scan_project "$project_dir" 2>&1) ;;
    muster_init_project)
      local config
      config=$(printf '%s\n' "$msg" | jq -r '.params.arguments.config // empty')
      if [[ -z "$config" ]]; then
        json_error "$id" -32602 "config is required for init_project"
        return
      fi
      result=$(tool_init_project "$project_dir" "$config" 2>&1) ;;
    muster_write_hook)
      local service hook content
      service=$(printf '%s\n' "$msg" | jq -r '.params.arguments.service // empty')
      hook=$(printf '%s\n' "$msg" | jq -r '.params.arguments.hook // empty')
      content=$(printf '%s\n' "$msg" | jq -r '.params.arguments.content // empty')
      if [[ -z "$service" ]] || [[ -z "$hook" ]] || [[ -z "$content" ]]; then
        json_error "$id" -32602 "service, hook, and content are required for write_hook"
        return
      fi
      result=$(tool_write_hook "$project_dir" "$service" "$hook" "$content" 2>&1) ;;
    muster_read_hook)
      local service hook
      service=$(printf '%s\n' "$msg" | jq -r '.params.arguments.service // empty')
      hook=$(printf '%s\n' "$msg" | jq -r '.params.arguments.hook // empty')
      if [[ -z "$service" ]] || [[ -z "$hook" ]]; then
        json_error "$id" -32602 "service and hook are required for read_hook"
        return
      fi
      result=$(tool_read_hook "$project_dir" "$service" "$hook" 2>&1) ;;
    muster_set_credential)
      local service key value
      service=$(printf '%s\n' "$msg" | jq -r '.params.arguments.service // empty')
      key=$(printf '%s\n' "$msg" | jq -r '.params.arguments.key // empty')
      value=$(printf '%s\n' "$msg" | jq -r '.params.arguments.value // empty')
      if [[ -z "$service" ]] || [[ -z "$key" ]] || [[ -z "$value" ]]; then
        json_error "$id" -32602 "service, key, and value are required for set_credential"
        return
      fi
      # Run directly (not in subshell) so array changes persist
      local entry="${service}:${key}"
      local _i=0 _found=false
      while (( _i < ${#_CRED_KEYS[@]} )); do
        if [[ "${_CRED_KEYS[$_i]}" == "$entry" ]]; then
          _CRED_VALS[$_i]="$value"
          _found=true
          break
        fi
        (( _i++ ))
      done
      if [[ "$_found" == "false" ]]; then
        _CRED_KEYS[${#_CRED_KEYS[@]}]="$entry"
        _CRED_VALS[${#_CRED_VALS[@]}]="$value"
      fi
      if [[ "$_found" == "true" ]]; then
        json_tool_result "$id" "Updated credential ${key} for ${service}"
      else
        json_tool_result "$id" "Stored credential ${key} for ${service}"
      fi
      return ;;
    muster_list_credentials)
      result=$(tool_list_credentials 2>&1) ;;
    muster_clear_credentials)
      # Run directly so array changes persist
      local _count=${#_CRED_KEYS[@]}
      _CRED_KEYS=()
      _CRED_VALS=()
      json_tool_result "$id" "Cleared ${_count} credential(s)"
      return ;;
    *)
      json_error "$id" -32601 "Unknown tool: ${tool_name}"
      return ;;
  esac

  json_tool_result "$id" "$result"
}

# ── Dispatch a single JSON-RPC message ──
dispatch_message() {
  local msg="$1"
  local method id
  method=$(printf '%s\n' "$msg" | jq -r '.method // empty')
  id=$(printf '%s\n' "$msg" | jq -r '.id // "null"')

  case "$method" in
    initialize)
      json_response "$id" "{\"protocolVersion\":\"2024-11-05\",\"capabilities\":{\"tools\":{}},\"serverInfo\":{\"name\":\"muster\",\"version\":\"${MUSTER_VERSION}\"}}"
      ;;
    "notifications/initialized")
      # No response needed
      ;;
    "tools/list")
      json_response "$id" "{\"tools\":${TOOLS_JSON}}"
      ;;
    "tools/call")
      handle_call "$msg" "$id"
      ;;
    "ping")
      json_response "$id" "{}"
      ;;
    *)
      if [[ "$id" != "null" ]]; then
        json_error "$id" -32601 "Method not found: ${method}"
      fi
      ;;
  esac
}

# ── Main protocol loop ──
_log "started (v${MUSTER_VERSION})"

while IFS= read -r line; do
  [[ -z "$line" ]] && continue

  # Check if input is a JSON-RPC batch (array of requests)
  line_type=$(printf '%s\n' "$line" | jq -r 'type' 2>/dev/null)

  if [[ "$line_type" == "array" ]]; then
    # Batch request: iterate over each element
    count=$(printf '%s\n' "$line" | jq 'length')
    i=0
    while (( i < count )); do
      msg=$(printf '%s\n' "$line" | jq -c ".[$i]")
      dispatch_message "$msg"
      (( i++ ))
    done
  else
    dispatch_message "$line"
  fi
done
